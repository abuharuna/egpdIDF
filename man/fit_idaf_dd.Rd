% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Idaf_functions.R
\name{fit_idaf_dd}
\alias{fit_idaf_dd}
\title{Function to fit egpdIDAF model}
\usage{
fit_idaf_dd(
  st_data_ad,
  init_param,
  durations,
  grid_area,
  formula,
  use_mle_init = F
)
}
\arguments{
\item{st_data_ad}{a list of size \code{length(grid_area)}. Each containing 1) a df of the
intensities (of various durations) of the given aggregation area, and
b) a vector of size \code{length(durations)}  containing the number of observations below a given censoring threshold.}

\item{durations}{a (vector) of durations}

\item{grid_area}{a (vector) of aggregation areas}

\item{formula}{a list (size = 3) of  formulars, one each for each egpd parameter}

\item{use_mle_init}{logical, defaults  to \code{FALSE}, if yes, an iterative pairwise likelihood fitting is done. See ...}
}
\value{
# A list:

   fits: egdp parameters fit for each duration seperately
   optim details, to check convergence
}
\description{
A regression based (data driven) IDAF model based on the egpd distribution.
 IDAF stands for Intensity-Duration-Area-Frequency.
}
\details{
to be added
}
\examples{
 ## load the data
 data(precip_areal)
  side_vec = c(0,1,2,3,4,6,8,11,13,16)
  grid_area = (1+2*side_vec)^2
  area_names = paste0("A_",grid_area,"km2")
 durations = c( 1,2, 3,  6,  10, 12,  16,  24, 48, 72)
 duration_names= c(paste0("D_", durations, "h"))
 declustering_duration = c( 3, 4, 5,  8,  10, 12,  16,   24, 48, 72)

 #extract the data  at the pixel location

\dontrun{

 #1.0 obtaining initial values. This is done by fitting EGPD locally to each data of A and D. ------
 ## Read  the 'help' of 'egpd_idf_init' function in the  'egpdIDF' package .

 # craere an emty array to store the parameters
  param_matrix = array(data = NA, dim = c( 5, length(durations), length(side_vec)),
                    dimnames = list( c("kappa", "sigma", "xi", "nrmse", "lower_c"),
                                     durations, grid_area))
 #iterate over the areal data, each time  aggregate the data into various durations, and fit egpd
 for (a in seq_along(area_names)) {
   cat(-a)
   station_data= aggregate_data(sample_data = areal_data,
         st_code = colnames(areal_data)[a+1], durations)

   #--- fit the egod:  Read  the 'help' of 'egpd_idf_init' function in the  'egpdIDF' package
   initial_params = egpd_idf_init(station_data = station_data,
                                         durations = durations,
                                         fitting_method = "mle",
                                         declustering_duration =  declustering_duration,
                                         auto_fit = F, use_r_optim = F)
   #  store the params
   param_matrix[, ,a] = rbind(initial_params$fits$kappa_param, initial_params$fits$scale_param,
                            initial_params$fits$shape_param, initial_params$fits$nrsme,
                            initial_params$fits$lower_threshold)
 }

 # 2. fitting the EGPD-IDAF  model -------
 ## 2.1  putting the data in the right format ----
 init_param = as.data.frame.table(param_matrix[1:5,,]) \%>\%
   set_names(c("param", "duration", "area", "value") )  \%>\%
    pivot_wider(names_from = "param",values_from = "value") \%>\%
   mutate_if(is.factor, ~ as.numeric(as.character(.)))  \%>\%  arrange(duration)

 st_data_ad =  map(seq_along(area_names), function(a) {
   # Aggregate the data to durations
   xx <-  aggregate_data(sample_data = areal_data,
      st_code = colnames(areal_data)[a+1], durations)
   names(xx) <- durations

   # Decluster each data and count the number of censored observations
   n_cens <- sapply(seq_along(declustering_duration), function(d) {
     data_dec =  decluster_set_NA(x = xx[[d]], init_time_step = 1,
      step = declustering_duration[d]) \%>\% na.omit
    #data_dec <- decluster_set_NA(xx[[d]], init_time_step, step = d)
    censoring_value <- init_param$lower_c[init_param$duration == durations[d] &
      init_param$area == grid_area[a]]
     sum(data_dec > 0 & data_dec < censoring_value)
   })

   # Filter and pivot the declustered data
   xx1 <- map(seq_along(declustering_duration), function(d) {
     data_dec <- decluster_set_NA(xx[[d]], init_time_step =1, step = declustering_duration[d])
     censoring_value <- init_param$lower_c[init_param$duration == durations[d]
      & init_param$area == grid_area[a]]
    data_dec[data_dec < censoring_value] <- NA
     data.frame(precip = data_dec, duration = durations[d], area = grid_area[a])
   }) \%>\%  do.call(what = rbind) \%>\%  arrange(duration) \%>\% drop_na

   # Return the filtered and pivoted data and the number of censored observations
   list(data = xx1, ncens = n_cens)
})

 ## 2.2  specifying the relationship ----------
 kappa_formula = "log(kappa) ~ area + log(area)*sqrt(duration)  + log(area)*duration"
 sigma_formula = "log(sigma) ~ area + duration*log(area) + log(area)*sqrt(duration)"
 xi_formula =  " xi ~ log(area)*sqrt(duration) + log(area)*duration"

 formula = list(kappa_formula, sigma_formula,  xi_formula)

 ## 2.3 fitting the model ---------
 fitted_idaf = fit_idaf_dd(st_data_ad = st_data_ad, init_param = init_param,
      durations = durations, grid_area = grid_area,formula = formula, use_mle_init = F)

 kappa_mat_fitted = fitted_idaf$kappa_param
 sigma_mat_fitted = fitted_idaf$scale_param
 xi_mat_fitted = fitted_idaf$shape_param

 ## 2.4  diagonostics (qqplots) of the model ----------
 for (a in seq_along(area_names)) {
   cat(-a)
  station_data= aggregate_data(sample_data = areal_data,
      st_code = colnames(areal_data)[a+1], durations)
  pp = map(seq_along(durations), function(d){
         qqplot_egpd(durations[d]*station_data[seq(1, nrow(station_data),
                         declustering_duration[d]),d],
                         kappa= kappa_mat_fitted[[a+1]][d],
                         sigma = sigma_mat_fitted[[a+1]][d]*durations[d],
                          xi = xi_mat_fitted[[a+1]][d])
     })
   p= ggarrange(plotlist = pp, ncol = 3, nrow = 4)
   print(p)

 }
#}
}
