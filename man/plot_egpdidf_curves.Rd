% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/post_process.R
\name{plot_egpdidf_curves}
\alias{plot_egpdidf_curves}
\title{Plot IDF Curves}
\usage{
plot_egpdidf_curves(
  station_data,
  kappa_fit,
  sigma_fit,
  xi_fit,
  durations,
  declustering_duration,
  npy,
  Tr_vec = c(2, 5, 10, 20, 50, 100),
  init_time_step = 1
)
}
\arguments{
\item{station_data}{data_frame of observation for a station (nobs x aggregation duration)}

\item{kappa_fit}{a numerical vector  of  egpd 'kappa'  parmater. Same length as \code{ncol(station_data)}}

\item{sigma_fit}{same as  \code{kappa_fit} but for egpd 'sigma'}

\item{xi_fit}{same as  \code{kappa_fit} but for egpd shape parammter (xi)}

\item{durations}{a (vector) of durations (same length as ncol of station_data)}

\item{declustering_duration}{a vector same length as \code{duration} .Whether the data should be temporally declustered, if yes the time step for each duration, or a vector of 1 otherwise}

\item{npy}{number of days per year. Eg if  \code{station_data} contains only data in summer, then \code{npy = 92}. If  for a year, then \code{npy = 365.25} etc}

\item{Tr_vec}{numerical vector of return periods fro which the curves are to be plotted.}

\item{init_time_step}{a scalar, eg 1 or 2. The time step to start declustering the data. eg, for hourly data, if  \code{declustering =3} and  \code{init_time_step = 2}, then the 2nd hour will be selected, and then a sequence is applied
If a character, then a weighted normalized root mean square error will be used.}
}
\value{
a ggplot object
}
\description{
The function plot IDF curves from a fitted egpdIDF model
}
\details{
to be added
}
