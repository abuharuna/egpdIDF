% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idf_functions.R
\name{egpd_idf_init}
\alias{egpd_idf_init}
\title{Function to estimates the initial parameters for the IDF_egpd models}
\usage{
egpd_idf_init(
  station_data,
  durations,
  declustering_duration,
  init_time_step = 1,
  fitting_method = "mle",
  left_censoring_value = 0,
  auto_fit = T,
  nrmse_tol = 0.1,
  simple_scaling = T,
  use_r_optim = F,
  nrsme_quantile = 0
)
}
\arguments{
\item{station_data}{data_frame of observation for a station (nobs x aggregation duration)}

\item{durations}{a (vector) of durations (same length as ncol of station_data)}

\item{declustering_duration}{a vector same length as \code{duration} .Whether the data should be temporally declustered, if yes the time step for each duration, or a vector of 1 otherwise}

\item{init_time_step}{a scalar, eg 1 or 2. The time step to start declustering the data. eg, for hourly data, if  \code{declustering =3} and  \code{init_time_step = 2}, then the 2nd timestep will be selected, and then a sequence is applied}

\item{fitting_method}{eiither \code{"mle"} for maximum likelihood or \code{"pwm"} for probability weighted momoments. Defaults to \code{"mle"}}

\item{left_censoring_value}{a scalar or vector of length(durations), defaults to \code{0}. The left censoring value to be applied to data of each duration. If a scalar is given, it will be divided (scaled) by durations. It will be ignored if  \code{auto_fit = TRUE}.}

\item{auto_fit}{logical, whether an automatic fit is to be done to find a censoring threshold that minimizes the normalized root mean square error; defaults to \code{TRUE}. Otherwise  the values in \code{left_censoring_value } will be used.}

\item{nrmse_tol}{a scalar, defaults to \code{0.1}. defaines a relatively good egpd fit. If higher, and \code{auto_fit=TRUE}, automatic fit is done}

\item{simple_scaling}{logical, defaults to \code{TRUE}, defines the initial values values that would be returned}

\item{use_r_optim}{logical, defaults  to \code{FALSE}, if yes, the code will be paralleled using \code{foreach}. And if in addition to  \code{use_r_optim = T},  \code{auto_fit = TRUE},
then  \code{optim} will be used to find the best lower censoring values. Otherwise (that is if \code{auto_fit = FALSE}), no automatic left censoring will be called, and only the values in \code{left_censoring_value } will be used in the paralleled fitting.}

\item{nrsme_quantile}{a number in percentage, or any character eg \code{nrsme_quantile = 90}, the normalized root mean square error will only be computed on excesses of the quaneile.  If a charanter, then a weighted normalized root mean square error will be used.
Only used if both \code{use_r_optim = T} and  \code{auto_fit = TRUE}}
}
\value{
# A list:
   init: the initial parameters to use for fitting a egpd IDF model
   fits: egdp parameters fit for each duration seperately
   regres_summary: summary of the lm fit of the sigma vs duration
}
\description{
each duration is fitted separately, then lm is fitted to estimate the parameters of the IDF (sigma0 as the intecept, etha as the -ve of the slope)
 kappa and xi as the median of the d_ estimates
}
\details{
to be added
}
\examples{
 ## load the data
 data("precipdata")

 ## Here the resolution of the data is in 'hours', we want to aggeregate the data up to 72 hours
 ## specify the aggregation durations

 durations =  c(1,2, 3,  6,  10, 12,  16, 18,  24, 48, 72)

 ## get the aggrageted data for each of the
 station_data= aggregate_data(sample_data = precipdata, st_code = "SCH",  durations = durations)

\dontrun{
 initial_params = egpd_idf_init(station_data = station_data,
                durations = durations, fitting_method = "mle",
                declustering_duration =  c(1,2,3,6,10,12, 16,18, 24, 48, 72), auto_fit = FALSE)
 ## check the fitted egpd parameters for each duration
 initial_params$fits$kappa_param
 initial_params$fits$scale_param
 initial_params$fits$shape_param

 ## check the quality of the fit
 initial_params$fits$nrsme

 ## for a good fit, 'nrsme" should be small.

 ##  its always good to  use left censoring with 'mle' fit. Lets try, and check the 'nrmse' again
 ##  we set "auto_fit=T", "nrmse_tol=0.1"  "use_r_optim=T" , "nrsme_quantile = 0".
 ## Check the arguments for their meaning
 initial_params = egpd_idf_init(station_data = station_data,
           durations = durations, fitting_method = "mle",
            declustering_duration =  c(1,2,3,6,10,12, 16,18, 24, 48, 72),
              auto_fit = TRUE, nrmse_tol = 0.1,use_r_optim = TRUE, nrsme_quantile = 0)
 ## check the quality of the fit
 initial_params$fits$nrsme
 ## check the parameters
 initial_params$fits$kappa_param
 initial_params$fits$scale_param
 initial_params$fits$shape_param
}
}
